<!DOCTYPE html>
<html>
  <head>
    <title>OpenShift Releases</title>
    <meta charset="UTF-8">
    <meta name="description" content="Graph of OpenShift releases and available updates." />
    <style type="text/css">
      html, body {
        margin: 0;
        padding: 0;
      }

      svg {
        display: block;
        position: absolute;
        margin: 0;
        width: 100%;
        height: 100%;
      }

      div#overlay {
        display: block;
        position: absolute;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <div id="overlay">
      <button id="architecture">Architecture (FIXME: dropdown to select architecture)</button>
      <button id="channel">Channel (FIXME: dropdown to select channel)</button>
      <button id="version">Version (FIXME: dropdown to select version)</button>
    </div>
    <script>
      var markRadius = 30;
      var architecture = 'amd64';
      var channel = 'stable-4.2';
      var version = null;

      // CORS header ‘Access-Control-Allow-Origin’ missing
      // var cincinnati = 'https://api.openshift.com/api/upgrades_info/v1/graph';
      var cincinnati = 'http://localhost:8081/';

      var graph = {
        nodes: [],
        edges: [],
      };

      var svg = d3.select('body').append('svg')
        .attr('preserveAspectRatio', 'xMidYMid meet')
        .attr('xmlns', 'http://www.w3.org/2000/svg')
        .attr('xmlns:xlink', 'http://www.w3.org/1999/xlink');

      function redraw(interval) {
        var height = window.innerHeight;
        var width = window.innerWidth;

        var nodes = JSON.parse(JSON.stringify(graph.nodes));  // deep copy
        var edges = JSON.parse(JSON.stringify(graph.edges));  // deep copy

        var parents = {};
        edges.forEach(edge => {
          if (parents[edge.target] === undefined) {
            parents[edge.target] = [edge.source];
          } else {
            parents[edge.target].push(edge.source);
          }
        });

        nodes.forEach((node, index) => {
          if (parents[index] === undefined) {
            node.rank = 1;
          }
        });
        for (let ranked = true; ranked;) {
          ranked = false;
          nodes.forEach((node, index) => {
            if (node.rank) {
              return;
            }
            var parentRanks = parents[index].map(i => nodes[i].rank);
            if (parentRanks.includes(undefined)) {
              return;
            }
            node.rank = Math.max(...parentRanks) + 1;
            ranked = true;
          });
        }
        var maxRank = Math.max(...nodes.map(node => node.rank));

        var bentEdges = [];
        edges.forEach(edge => {
          var s = nodes[edge.source];
          var t = nodes[edge.target];
          var i = {rank: (t.rank + s.rank) / 2};  // Intermediate node
          var d = (t.rank - s.rank);
          nodes.push(i);
          edge.distance = 2*d;
          edges.push({source: s, target: i, distance: d}, {source: i, target: t, distance: d});
          bentEdges.push([s, i, t])
        });

        svg.selectAll('*').remove();
        var edge = svg.selectAll('path.edge')
          .data(bentEdges)
          .enter()
          .append('path')
            .classed('edge', true)
            .attr('fill', 'none')
            .attr('stroke', 'black')
            .attr('stroke-opacity', '0.25');

        var node = svg.selectAll('a.release-circle')
          .data(nodes.filter(node => node.version))
          .enter()
          .append('a')
            .classed('release-circle', true)
            .attr('xlink:href', node => node.metadata.url)
          .append('circle')
            .attr('r', markRadius)
            .attr('fill', 'white')
            .attr('stroke', 'black')
          .call(d3.drag()
            .on('start', dragstarted)
            .on('drag', dragged)
            .on('end', dragended));
        node.append('title')
          .text(node => node.version);

        var nodeText = svg.selectAll('text.release-text')
          .data(nodes.filter(node => node.version))
          .enter()
          .append('a')
            .classed('release-text', true)
            .attr('xlink:href', node => node.metadata.url)
          .append('text')
            .style('dominant-baseline', 'middle')
            .style('text-anchor', 'middle')
            .text(node => node.version);

        var simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(edges).distance(edge => edge.distance))
          .force('charge', d3.forceManyBody().strength(-300))     // Repel all nodes from each other
          .force('center', d3.forceCenter(width / 2, height / 2))  // Attract nodes to the center of the SVG
          .force('rank', rankForce)
          .on('tick', position);

        function rankForce(alpha) {
          nodes.forEach(node => {
            if (!node.rank) {
              return;
            }
            var dy = 100 * (node.rank - maxRank / 2) - node.y;
            node.vy += dy * alpha * 0.1;
          });
        }

        function position() {
          edge
            .attr('d', e => `M ${e[0].x},${e[0].y} S ${e[1].x},${e[1].y} ${e[2].x},${e[2].y}`);

          node
           .attr('cx', node => node.x)
           .attr('cy', node => node.y);

          nodeText
            .attr('x', node => node.x)
            .attr('y', node => node.y);
        }

        function dragstarted(d) {
          if (!d3.event.active) simulation.alphaTarget(0.3).restart();
          d.fx = d.x, d.fy = d.y;
        }

        function dragged(d) {
          d.fx = d3.event.x, d.fy = d3.event.y;
        }

        function dragended(d) {
          if (!d3.event.active) simulation.alphaTarget(0);
          d.fx = null, d.fy = null;
        }

        if (interval) {
          window.setTimeout(refetch, interval, interval);
        }
      }

      function deepEqual(a, b) {
        if (a && b && typeof a == 'object' && typeof b == 'object') {
          if (Object.keys(a).length != Object.keys(b).length) return false;
          for (var key in a) if (!deepEqual(a[key], b[key])) return false;
          return true;
        } else return a === b;
      }

      function refetch(interval) {
        var params = new URLSearchParams();
        params.append('arch', architecture);
        params.append('channel', channel);
        d3.json(`${cincinnati}?${params.toString()}`)
          .then(data => {
            var newGraph = {
              nodes: data.nodes,
              edges: data.edges.map(edge => ({source: edge[0], target: edge[1]})),
            };
            if (deepEqual(newGraph, graph)) {
              console.log('no change to the graph');
              if (interval) {
                console.log('scheduling a later refetch');
                window.setTimeout(refetch, interval, interval);
              }
            } else {
              console.log('new graph; redrawing');
              graph = newGraph;
              redraw(interval);
            }
          })
          .catch(alert);
      }

      function resize() {
        var height = window.innerHeight;
        var width = window.innerWidth;

        svg
          .attr('width', width)
          .attr('height', height);

        redraw();
      }

      refetch(60000);
      resize();

      window.addEventListener('resize', resize);
      window.addEventListener('keyup', event => {
          if (event.key === 's') {
          const el = document.createElement('textarea');    // Create a <textarea> element
            el.value = svg.node().outerHTML;                // Set its value to the string that you want copied
            el.setAttribute('readonly', '');                // Make it readonly to be tamper-proof
            el.style.position = 'absolute';
            el.style.left = '-9999px';                      // Move outside the screen to make it invisible
            document.body.appendChild(el);                  // Append the <textarea> element to the HTML document
            const selected =
              document.getSelection().rangeCount > 0        // Check if there is any content selected previously
                ? document.getSelection().getRangeAt(0)     // Store selection if found
                : false;                                    // Mark as false to know no selection existed before
            el.select();                                    // Select the <textarea> content
            document.execCommand('copy');                   // Copy - only works as a result of a user action (e.g. click events)
            document.body.removeChild(el);                  // Remove the <textarea> element
            if (selected) {                                 // If a selection existed before copying
              document.getSelection().removeAllRanges();    // Unselect everything on the HTML document
              document.getSelection().addRange(selected);   // Restore the original selection
          }
        }
      });
    </script>
  </body>
</html>
