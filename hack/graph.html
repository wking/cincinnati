<!DOCTYPE html>
<html>
  <head>
    <title>OpenShift Releases</title>
    <meta charset="UTF-8">
    <meta name="description" content="Graph of OpenShift releases and available updates." />
    <style type="text/css">
      html, body {
        margin: 0;
        padding: 0;
      }

      svg {
        display: block;
        position: absolute;
        margin: 0;
        width: 100%;
        height: 100%;
      }

      div#overlay {
        display: block;
        position: absolute;
        z-index: 1000;
      }
    </style>
  </head>
  <body>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <div id="overlay">
      <button id="architecture">Architecture (FIXME: dropdown to select architecture)</button>
      <button id="channel">Channel (FIXME: dropdown to select channel)</button>
      <button id="version">Version (FIXME: dropdown to select version)</button>
    </div>
    <script>
      var markRadius = 30;
      var architecture = 'amd64';
      var channel = 'stable-4.2';
      var version = null;

      // CORS header ‘Access-Control-Allow-Origin’ missing
      // var cincinnati = 'https://api.openshift.com/api/upgrades_info/v1/graph';
      var cincinnati = 'http://localhost:8081/';

      var sourceGraph = {
        nodes: [],
        edges: [],
      };

      var workingGraph = {  // updated after nodes are positioned
        nodes: [],
        edges: [],
      };

      var svg = d3.select('body').append('svg')
        .attr('preserveAspectRatio', 'xMidYMid meet')
        .attr('xmlns', 'http://www.w3.org/2000/svg')
        .attr('xmlns:xlink', 'http://www.w3.org/1999/xlink');

      function redraw(interval) {
        var height = window.innerHeight;
        var width = window.innerWidth;

        svg.selectAll('*').remove();
        var edge = svg.selectAll('line')
          .data(workingGraph.edges)
          .enter()
          .append('line')
            .attr('stroke', 'black')
            .attr('stroke-opacity', '0.25');

        var node = svg.selectAll('a.release-circle')
          .data(workingGraph.nodes)
          .enter()
          .append('a')
            .classed('release-circle', true)
            .attr('xlink:href', node => node.metadata.url)
          .append('circle')
            .attr('r', markRadius)
            .attr('fill', 'white')
            .attr('stroke', 'black');
        node.append('title')
          .text(node => node.version);

        var nodeText = svg.selectAll('text.release-text')
          .data(workingGraph.nodes)
          .enter()
          .append('a')
            .classed('release-text', true)
            .attr('xlink:href', node => node.metadata.url)
          .append('text')
            .style('dominant-baseline', 'middle')
            .style('text-anchor', 'middle')
            .text(node => node.version);

        var simulation = d3.forceSimulation(workingGraph.nodes)
          .force('link', d3.forceLink(workingGraph.edges))
          .force('charge', d3.forceManyBody().strength(-1000))     // Repel all nodes from each other
          .force('center', d3.forceCenter(width / 2, height / 2))  // Attract nodes to the center of the SVG
          .on('end', position);  // When the simulation completes, position the nodes and edges

        function position() {
          edge
            .attr('x1', edge => edge.source.x)
            .attr('y1', edge => edge.source.y)
            .attr('x2', edge => edge.target.x)
            .attr('y2', edge => edge.target.y);

          node
           .attr('cx', node => node.x)
           .attr('cy', node => node.y);

          nodeText
            .attr('x', node => node.x)
            .attr('y', node => node.y);
        }

        if (interval) {
          window.setTimeout(refetch, interval, interval);
        }
      }

      function deepEqual(a, b) {
        if (a && b && typeof a == 'object' && typeof b == 'object') {
          if (Object.keys(a).length != Object.keys(b).length) return false;
          for (var key in a) if (!deepEqual(a[key], b[key])) return false;
          return true;
        } else return a === b;
      }

      function refetch(interval) {
        var params = new URLSearchParams();
        params.append('arch', architecture);
        params.append('channel', channel);
        d3.json(`${cincinnati}?${params.toString()}`)
          .then(data => {
            var newGraph = {
              nodes: data.nodes,
              edges: data.edges.map(edge => ({source: edge[0], target: edge[1]})),
            };
            if (deepEqual(newGraph, sourceGraph)) {
              console.log('no change to the graph');
              if (interval) {
                console.log('scheduling a later refetch');
                window.setTimeout(refetch, interval, interval);
              }
            } else {
              console.log('new graph; redrawing');
              workingGraph = JSON.parse(JSON.stringify(newGraph));  // deep copy
              sourceGraph = newGraph;
              redraw(interval);
            }
          })
          .catch(alert);
      }

      function resize() {
        var height = window.innerHeight;
        var width = window.innerWidth;

        svg
          .attr('width', width)
          .attr('height', height);

        redraw();
      }

      refetch(60000);
      resize();

      window.addEventListener('resize', resize);
      window.addEventListener('keyup', event => {
          if (event.key === 's') {
          const el = document.createElement('textarea');    // Create a <textarea> element
            el.value = svg.node().outerHTML;                // Set its value to the string that you want copied
            el.setAttribute('readonly', '');                // Make it readonly to be tamper-proof
            el.style.position = 'absolute';
            el.style.left = '-9999px';                      // Move outside the screen to make it invisible
            document.body.appendChild(el);                  // Append the <textarea> element to the HTML document
            const selected =
              document.getSelection().rangeCount > 0        // Check if there is any content selected previously
                ? document.getSelection().getRangeAt(0)     // Store selection if found
                : false;                                    // Mark as false to know no selection existed before
            el.select();                                    // Select the <textarea> content
            document.execCommand('copy');                   // Copy - only works as a result of a user action (e.g. click events)
            document.body.removeChild(el);                  // Remove the <textarea> element
            if (selected) {                                 // If a selection existed before copying
              document.getSelection().removeAllRanges();    // Unselect everything on the HTML document
              document.getSelection().addRange(selected);   // Restore the original selection
          }
        }
      });
    </script>
  </body>
</html>
